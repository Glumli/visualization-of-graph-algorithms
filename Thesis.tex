\documentclass
[
	paper = a4,
    pagesize,
	12 pt,
	oneside,                       % Chose ›oneside‹ for digital version, ›twoside‹ for printed version.
    open = right,
	DIV = calc,
	BCOR = 0 mm,                   % Binding correction. Only necessary for printed version. Depends on actual binding.
	bibtotoc
]
{scrbook}

\input{Files/Commands.tex}

\myTitle{High-Level visualization of graph algorrithms}  % Change!
\myName{Julius Milian Severin}  % Change!
\myDateOfBirth{March~12, 1995}  % Change!
\myPlaceOfBirth{Berlin, Germany}  % Change!
\mySubject{{Graph Algorithms}{Visualization}}  % Change!

\input{Files/Preamble.tex}



\begin{document}


\frontmatter
% Title Page
\input{Files/Title_Page.tex}

% Abstract
\input{Files/Abstract.tex}

% Table of Contents
\input{Files/Table_of_Contents.tex}


\mainmatter
\chapter{Introduction} \label{introduction}
Graphs are a common structure in computer science.
Therefore developing more efficient graph algorithms plays a big role in algorithm engineering.
During the process of development knowing how the algorithm behaves is really important.
Firstly developing an algorithm is an iterative process it is fundamental to communicate about the different approaches and therefore create an understanding of them in the whole team.
Furthermore, the developed algorithms can become quite complex and therefore the idea of how the algorithms should behave and the way they actually behave on real graph data can diverge quite a lot.
\par
As the eyes are a fast way to access information a good way to achieve this understanding is to visualize the progress of the algorithm.
Though there are many tools for visualizing graphs, there is still a lack of algorithm visualization tools.
Therefore writing an own visualization that fits one's needs might be necessary.
In the following, we will describe the process of developing a sensemaking visualization the example of a shortest path algorithm. The algorithm was developed on a geographical tiled road network with the special requirement to reduce the amount of tile-accesses during the algorithm.

\chapter{Prelimanaries} \label{questions}

This chapter starts by giving all important information about the graph and the specification of the algorithm itself followed by a selection of questions that came up during the process of developing the visualization.


\section{Problem Specification} \label{specification}
% \begin{itemize}
%     \item Knoten
%     \begin{itemize}
%         \item mit Koordinaten versehen
%     \end{itemize}
%     \item Kanten
%     \begin{itemize}
%         \item gerichtet
%         \item mit Geschwindigkeit + Länge
%     \end{itemize}
% \end{itemize}

Before we start building our visualization, we are going to take a look at the graph the algorithms will be running on.
As a geographical graph is given, every node has some coordinates according to its position on the earth.
The edges are directed and weighted, whereby the weight is given by length and speed.
In \ref{introduction} we already mentioned tiles.
Those tiles have been introduced by the Navigation Data Standart (NDS). It divides the graph according to a geographical grid.
Therefore every tile is bounded by a coordinate on every site.
As the tiles are encrypted and compressed the costs for loading them are the main cost factor during the algorithm.



\section{Displaying the Graph}

% \begin{itemize}
%     \item Wie ordnet man Knoten an?
%     \begin{itemize}
%         \item Koordinaten
%     \end{itemize}
%     \item Wie repräsentiert man Knoten?
%     \begin{itemize}
%         \item Kreise
%         \item keine explizite Darstellung -> start und End von Kante
%     \end{itemize}
%     \item Wie repräsentiert man Kanten?
%     \begin{itemize}
%         \item Linie
%     \end{itemize}
% \end{itemize}

When trying to visualize a graph algorithm a good start is to think about a way to display the graph itself first.
Therefore it is necessary to find a way to arrange the nodes and think about a way to represent nodes and edges in general.



\section{Displaying the Algorithm}

Even though visualizing graphs on a high level is a common thing and impressive graphs is a even used for marketing reasons (e.g. Facebook), visualizing algorithms itself is mostly seen in doctrine on a small scale.

\subsection{Basics}

% \begin{itemize}
%     \item Welcher Bereich ist am Anfang im Bild?
%     \begin{itemize}
%         \item Zentrum
%         \begin{itemize}
%             \item Start
%             \item Mitte zwischen Start + Ziel
%             \item Mitte der Suchfront
%         \end{itemize}
%     \end{itemize}
%     \item Welche Features sind noch Sinnvoll/nötig? // vielleicht eher zum Fazit?
%     \begin{itemize}
%         \item Zoom + Bewegen
%         \item Schrittweise vor/zurück (je nach visualisiertem)
%     \end{itemize}
% \end{itemize}

Since the visualization of graph algorithms is not such common, there are multiple basic questions that need to be answered.
Which segment should be shown in the beginning? How to visualize the progressing algorithm?
And which basic features should be included for increasing the accessibility of the information displayed.

\subsection{Displaying the Tiles}

% \begin{itemize}
%     \item  Wie werden Tiles repäsentiert?
%     \begin{itemize}
%         \item Durch alle enthaltenden Kanten
%         \item Durch Rechtecke
%     \end{itemize}
% \end{itemize}

The in \ref{specification} we already introduced the tiles that play a major role in the algorithms developed.
Therefore we need to find a way to make the tiles visible for the user.


\subsection{Visualizing the Cache}

% \begin{itemize}
%     \item Wie kann man den Cache Visualisieren?
%     \begin{itemize}
%         \item Einfärbung der aktuell geladenen Tiles
%     \end{itemize}
%     \item Wie kann man Mehrfachladungen repräsentieren?
%     \begin{itemize}
%         \item Farbe
%         \begin{itemize}
%             \item Weiß zu Rot
%             \item Grün zu Rot
%         \end{itemize}
%     \end{itemize}
% \end{itemize}

In the algorithms that should be developed the cache plays a role as well.
Tiles only need to be loaded when they are not in the cache yet.
So the relevant information is not how often a tile is accessed but how often a tile is accessed when it was not in the cache before.
Hence we need to find a way to display that information as well.


\section{Compare algorithms}

% \begin{itemize}
%     \item Wie kann man mehrere Algorithmen miteinander vergleichen?
%     \begin{itemize}
%         \item Nebeneinander laufen lassen
%         \item Entergebnis vergleichen
%         \item Differenz anzeigen
%     \end{itemize}
% \end{itemize}

After having answered all those questions introduced in the previous chapters we might also want to compare different algorithms. Is there maybe a way that includes more than just starting the visualization with two different algorithms and put them next to each other?



\section{Miscellaneous}

% \begin{itemize}
%     \item Welche Features sind noch sinnvoll?
%     \begin{itemize}
%         \item Bei Bedarf Graph einblenden
%         \begin{itemize}
%             \item Einfarbig
%             \item Farben als repräsentierung von Geschwindigkeiten
%         \end{itemize}
%     \end{itemize}
% \end{itemize}

In the end we will discuss some additional fancy features to give the visualization the last fancy touch.

\todo{END}

\chapter{Buillding the Visualization}

In this chapter we will discuss the questions introduced in \ref{questions}.


\section{Displaying the Graph}

This section we will take a closer look at the problematics introduced by \ref{graph} starting by the problem of aranging the nodes.
As every node has given unique coordinates we will use those to arrange them on the screen.
Therefore there are already many projections that calculate the position on the screen for given coordinates.
The porbably most intuitive way of projecting coordinates is to just see the longitude and the latitude as coordinates on a two-dimensional graph.
This projection is called Equirectangular Projection.
\par
An other common projection is the Mercator Porjection.
In Mercator Projection the longitudes are all equally spaced but the latitudes move away from each other the bigger the distance to the equator becomes.

\begin{figure}[h!]
	\includegraphics[width=.5\textwidth]{Images/Equirectangular_projection_SW.jpg}
	\includegraphics[width=.5\textwidth]{Images/Mercator_projection_SW.jpg}
\caption[]{Equirectangular Projection(left) vs. Mercator Projection(right)}
\label{fig:search_fronts_ell}
\end{figure}



As every node has unique coordinates that maps to their position on the earth the first idea of arrangement is to just use the longitude as x-value and the latitude as y-value und plot them as if the earth was a rectangle.
This seems to be the easiest way to plot the nodes.
An alternative would be to use one of the more common projections as for example the mercator projection.
We could also ignore the given coordinates and try to order the nodes based on the edges and try to archive that the costs of an edge is represented by its length in the visualization.



As the benfit
Warum einfache darstellung?

\paragraph{Nodes}
In most visualizations used for (Lehre) nodes are represented by a circle but those only display small graphs. As we are going to display much bigger graphs



\section{Displaying the Algorithm}


\subsection{Basics}


\subsection{Displaying the Tiles}


\subsection{Visualizing the Cache}


\section{Compare algorithms}


\section{Miscellaneous}

\chapter{Outlook}
\begin{itemize}
	\item verschiedene Projektionen
	\item knoten anordnen mit kanten mit länge = kosten
\end{itemize}


% \chapter{The Solutions}
%
% \section{Displaying Edges} \label{edges_only}
% As the nodes and edges seem to be the most important part of an algorithm the first approach of building our visualization was to draw all nodes and edges as soon as they were processed.
%
% \begin{figure}[H]
%     \centering
%     \includegraphics[width = 1.0\textwidth]{placeholder.png}
%     \caption[HPI logo]{\label{fig:edges_only}Edges-only visualization.}
% \end{figure}
%
% As we see the basic search front is shown in this visualization prette good, but every information about the tiles is missing.
% Therefore we start drawing every edge of a blocks as soon as they is accessed the first time.
%
% \begin{figure}[H]
%     \centering
%     \includegraphics[width = 1.0\textwidth]{placeholder.png}
%     \caption[HPI logo]{\label{fig:edges_only_blocks}Modification of the edges-only visualization. Unloaded edges in already loaded blocks are now plottet as gray lines.}
% \end{figure}
%
% As we see it is now possible to see the basic tile strucure the algorithm has to handle but there are still multiple shortcomes.
% When the algorithm watches already explored edges the user doesn't see any movement on the screen.
% Thus a big part of the algorithm stays unvisualized.
% In adition the tile structure is not recognizable on bigger graphs and particular in the inner graph.
%
% \section{Displaying tiles}
% As mentionioned in \ref{edges_only} the tile structure of the map is still not present enough in regard of their role for the algorithm.
% Hence we now want to represent the tiles by rectangles. As base we use the visualization from \ref{edges_only}.
%
% \begin{figure}[H]
%     \centering
%     \includegraphics[width = 1.0\textwidth]{placeholder.png}
%     \caption[HPI logo]{\label{fig:edges_only_blocks} Showing tile borders as soon as the first node was accessed. }
% \end{figure}
%
% By adding the rectangles to the visualization we solved the problem of unrecogniseable tile borders.
% But still there is big part missing in the visaulization-process. The problem of missing movement in the inner graph mentioned in \ref{edges_only} is still present.
% Hence we will take a look at possible solutions in the next sections.
% Since displaying all edges leads to a bad performance on a bigger routes and as they do not really add value to the visualization on a higher level we will continue using only the rectanglerepresentation of the tiles.
%
% \subsection{Time based coloring}
% The first aproach for solving this problem is to
%
% \subsection{Cache based coloring}
%
% \section{Displaying Graph in background}
%
% \section{Diff between Searchfronts}
%
% \section{basic features}
% - zoom\\
% - stepping threw time\\
%



% \chapter{Gedanken}
% NDS motivieren?
% Inwieweit das Projekt erklären?
% Einzelne Features:
% Wie genau auf Algorithmen eingehen?
% Nur verlinken?
% Erst Wünsche an Visualisierung?
%
% Historisch rangehen?\\
%
% Introduction\\
% Graphs important -> developing graph algorithms important -> Bad results/hard to imagine how the algorithm works in reality -> Visualizeing helps to access information -> Visualizing the algorithm -> bachelorproject -> problem -> building a visualization based on problem\\
% Main part\\
% historische rangehensweise? --> Motivation --> resultat --> relektieren --> repeat\\
% Fazit\\
% Resultat verallgemeinern --> Maß zwischen planen und baunen finden --> schnell beginnen --> feedback von nutzern\\
%
% Gliederung
% Einleitung
% Probleme
% 	Graphstruktur
% 	Wie stell ich den Graph dar?
% 		Wo ist welcher Knoten?
%
% 	Wie stelle ich den Algorithmus dar?
% 	Wie beziehe ich die Tiles ein?
% 	Wie stelle ich den Cache dar?
% Lösungen
% Ausblick und Fazit
%
% \chapter{Chapter}
%
% \lettrine[findent = -0.3 em, nindent = 0.7 em]{A}{} small example as proposed by~\citet{test}.\myfootnote[-0.2]{The footnote number shouldn’t be in superscript down here.} Just some text referring to~\Cref{fig:HPI} and citing~\citet{test2}.\myfootnote[-0.2]{And another footnote.}
%
% \begin{figure}
%     \centering
%     \includegraphics[width = 9 cm]{HPI_Logo.pdf}
%     \caption[HPI logo]{\label{fig:HPI}That’s the logo of the HPI. Naturally, it comes without its obligatory safe zone.}
% \end{figure}
%
% \section{Section}
%
% \subsection{Subsection}
%
% \subsubsection{Subsubsection}
%
% \newpage
% More text.
% \newpage
% Even more text.

% References
\input{Files/Bibliography.tex}

\chapter*{Independence Declaration}
\input{Files/Independence_Declaration.tex}


\end{document}
